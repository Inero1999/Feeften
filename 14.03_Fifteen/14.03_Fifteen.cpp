// 14.03_Fifteen.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <stdlib.h> //Содержит функции randomize и random
#include <stdio.h>
#include <conio.h> //Содержит функции clrscr и getch
using namespace std;
int Field[4][4];
int x, y;
char d;

void CreateField()
{
    bool NumIsFree[15]; //NumIsFree[i] показывает, определили ли мы уже позицию i-й костяшки
    int Nums[15]; //Nums[i] содержит номер костяшки, находящейся в i-й позиции
    for (int i = 0; i < 15; i++) //Объявляем, что изначально все костяшки свободны
        NumIsFree[i] = true;
    srand(time(0)); // при каждом прогоне программы получать разные последовательности псевдослучайных чисел
    bool Ok; //Флаг, определяющий корректность выбора костяшки для данной позиции
    int RandNum; //Номер костяшки, генерируемый в дальнейшем случайным образом
    for (int i = 0; i < 15; i++) //Нам надо определить номер костяшки, находящейся в каждой из 15 позиций поля
    {
        Ok = false; //Каждый раз сбрасываем значение флага
        while (!Ok) //Продолжаем случайным образом определять номер костяшки, пока он не окажется корректным
        {
            RandNum = rand()%15+1; //random(n) генерирует псевдослучайное число от 0 до n - 1, а нам нужно от 1 до 15
            if (NumIsFree[RandNum - 1]) //Если костяшка с таким номером еще свободна (помним, что массивы нумеруются начиная с нуля)
                Ok = true; //то мы определили ее номер корректно
        }
        Nums[i] = RandNum; //Записываем этот корректный номер в i-ю позицию
        NumIsFree[RandNum - 1] = false; //Костяшка с этим номером теперь занята
    }
    int Chaos = 0; //Количество беспорядков на поле
    int CurrNum; //Костяшка, для которой мы рассматриваем беспорядки
    for (int i = 0; i < 14; i++) //Считаем для костяшек на первых 14 позициях (для 15-й это бессмысленно)
    {
        CurrNum = Nums[i];
        for (int j = i + 1; j < 15; j++)
            if (CurrNum > Nums[j])
                Chaos++;
    }
    if (Chaos % 2 == 1) //Если общее число беспорядков нечетное,
    { //меняем местами костяшки на 14-й и 15-й позициях
        int temp = Nums[13];
        Nums[13] = Nums[14];
        Nums[14] = temp;
    }
    for (int i = 0; i < 15; i++)
        Field[i % 4][i / 4] = Nums[i]; //a % b - остаток от деления a на b
    Field[3][3] = 0;
    x = 3; y = 3;
}
void DrawField() //Вариант, подходящий для всех реализаций
{
    system("cls"); //Очищаем экран
    for (int j = 0; j < 4; j++) //Рисуем построчно четыре горизонтальных ряда костяшек
    {
        for (int i = 0; i < 4; i++) //Рисуем верхнюю часть ряда
        {
            if (Field[i][j])
                cout << "++++";
            else
                cout << "    ";
        }
        cout << '\n';
        for (int i = 0; i < 4; i++) //Рисуем среднюю часть ряда (с номерами)
        {
            if (Field[i][j])
            {
                cout << "+";
                cout.width(2);
                cout << Field[i][j]<< "+";
            }
            else
                cout << "    ";
        }
        cout << '\n';
        for (int i = 0; i < 4; i++) //Рисуем нижнюю часть ряда
        {
            if (Field[i][j])
                cout << "++++";
            else
                cout << "    ";
        }
        cout << '\n';
    }
}
void Move(char d)
{
    switch (d)
    {
    case 'a':
    {
        if (x < 3)
        {
            Field[x][y] = Field[x + 1][y];
            Field[x + 1][y] = 0;
            x++;
        }
    } 
    break;
    case 'w':
    {
        if (y < 3)
        {
            Field[x][y] = Field[x][y + 1];
            Field[x][y + 1] = 0;
            y++;
        }
    } break;
    case 'd':
    {
        if (x > 0)
        {
            Field[x][y] = Field[x - 1][y];
            Field[x - 1][y] = 0;
            x--;
        }
    } break;
    case 's':
    {
        if (y > 0)
        {
            Field[x][y] = Field[x][y - 1];
            Field[x][y - 1] = 0;
            y--;
        }
    }
    break;
    }
}
bool FieldIsCorrect()
{
    for (int i = 0; i < 15; i++)
        if (Field[i % 4][i / 4] != i + 1)
            return false; //При первом же нахождении несоответствия выходим и возвращаем false
    return true;//Если не найдено ни одного несоответствия - поле собрано верно
}
    
        
    

int main()
{
    char b;
    cout << " Menu Game . " << endl;
    cout << " 'q' - quit game " << endl;
    cout << " 'w' - UP " << endl;
    cout << " 's' - DOWN " << endl;
    cout << " 'a' - LEFT " << endl;
    cout << " 'd' - RIGHT " << endl;
    cout << " Enter any key for begin. ";
    cin >> b;
    CreateField(); //Генерация поля
    DrawField(); //Первоначальное рисование поля
    char c; //В эту переменную мы считываем символ нажатой клавиши
    while (!FieldIsCorrect()) //Игровой цикл (выполняется пока поле не будет собрано)
    {
        cin >> c; //Считываем нажатие клавиши
        switch (c) //В зависимости от нажатой клавиши (от ее целочисленного кода) двигаем костяшки
        {
        case 'a': Move(c); break; //Нажата клавиша "Влево"
        case 'w': Move(c); break; //Нажата клавиша "Вверх"
        case 'd': Move(c); break; //Нажата клавиша "Вправо"
        case 's': Move(c); break; //Нажата клавиша "Вниз"
        case 'q': return 0; //Нажата клавиша "Escape"
        }
        DrawField(); //Рисование поля
    }
    cout << "\n\nПоздравляю! Великолепно! ";
}


// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
